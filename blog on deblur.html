<html>
<head>
	<link rel="stylesheet" href="style.css">
<title> Blog on DeBlurring </title>
</head> 
<body>
<center> <h1> <u> <b> BLOG ON DEBLLURRING </b> </u> </h1> </center>
<br> <br> 
<p >  Recently, as I was going through my gallery I found many images that were pretty good but were blurred. This got me to think if there was some way to remove blur from these images. 
Since I am learning python these days so I decided to use my knowledge of python to remove blur from images.
As I was looking for ways, I came across a word <b> kernel </b> which played an important role in deblurring. I wondered what exactly is kernel?
 </p> <br> <br>
 <h2> <u> What is Kernel? </u></h2>
<p >  A <b> kernel </b>,convolution matrix,or mask in image processing is a small matrix that is used for various applications like blurring, sharpening, embossing, edge detection, etc which is done by a convolution between an image and a kernel. </p> 
<br> <br>
<h2> <u> 2D CONVOLUTION IN IMAGES </u></h2>

<p>While reading about kernel I saw the word Convolution and a question popped in my mind that what is convolution and how is it applied on images? <br>
Convolution, a simple mathematical operation, is a way of `multiplying together' two arrays of numbers having different sizes but the same dimensionality to produce a third array of numbers of the same dimensionality.<br>

When convolution operation is applied to an image, then it is can be said that a simple mathematical operation is done over the image. The values of the pixels in the image are changed to some degree during convolution operation. 
kernel or the filter is used to carry out convolution operation .
</p>
<br> 
<center> <img src="figure1.jpg"> </center>
<br><p>
For example, it can be seen in the figure that a 3×3 kernel is applied over a 7×7 dimensional image. By taking the values of the kernel into consideration, we can change the values of the image pixels.
By using the identity kernel, as given below, for carrying out the convolution process on an image, as a result, we get an image that is the same as the original image. 
</p> <br>
<center><img src="figure2.jpg"></center>
<br>
<p> Note that by using a kernel, detecting and highlighting of edges, sharpening, and un sharpening images can be done. </p>
<br>
<h2> <u> DEBLURRING OF IMAGES </u></h2> 
<p>
After learning some basic concepts about deblurring, I looked into ways to deblur an image in python. I found many methods to deblur like by Lucy Richardson Algorithm, using Wiener filter, Sharpening filter, etc. Among all these methods the one I liked the most was deblurring by sharpening filter which is there in the open CV.
I personally was able to understand it the best so I decided to proceed with it.
 </p>
<br>
<h2> <u> DEBLURRING OF IMAGES BY SHARPENING FILTER </u></h2>
<br>
<div class="row">
  <div class="column"> 
  	<img src = "roseblur.jpg"> 
  	<figcaption> Blurred image </figcaption> </div>
    <div class="column"> 
    	<img src ="rosesharpen.jpg"> 
    	<figcaption> Sharepened image </figcaption></div>
    <div class="column"> 
    	<img src="rosedenoise.jpg">
    	<figcaption>denoised figure </figcaption></div>
    </div>
<br>
<p> For deblurring images by this method there are 2 steps to be followed:
<ul type="1">
1.	First is to sharpen the image.<br> 
2.	Then denoise it to remove noise from the image.</ul><br>
Let’s start with deblurring.<br>
I have deblurred images using open CV library.</p>
<br> 
<h2> <u>PRE REQUISITES FOR DEBLURRING USING OPEN CV </u></h2>
<h3> <u> LIBRARIES </u></h3>
<p> Before starting with deblurring using open cv make sure you have installed the following libraries. </p>
<ol type="1"> <p>
<li> Open CV:It is a Python library that can be used to solve computer vision problems. 
    This library can be installed by writing the following code in command prompt or anaconda prompt: <b> Pip install opencv-python </b>
         It is imported as <b> import cv2 </b> in the code. </li> <br>
<li> NumPy :  NumPy is a python library used for working with arrays. It also has functions for working in domain of linear algebra, fourier transform, and matrices.
This library is usually pre installed in python (Anaconda 3). But if its not there then it can be installed by writing the following code in command prompt or anaconda prompt: <b> Pip install numpy. </b>
It is imported as <b> import numpy </b> in the code. </li> 
</p></ol>
<h2> <u> DEBLURRING OF IMAGES </u></h2>
<p> The code I used to deblur my images is:  </p>
<h3> <u> CODE </u></h3>
<p bgcolor ="black"><b>  import cv2 <br>
import numpy as np <br>

image = cv2.imread('lena2.jpg') <br>

sharpen_kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]]) <br>
sharpen = cv2.filter2D(image, 0 , sharpen_kernel) <br>

deblurred = cv2.fastNlMeansDenoisingColored(sharpen,None,10,10,7,21) <br>

cv2.imshow(‘deblureed’, deblurred) <br>
cv2.waitKey () <br> </b>
</p>
<h3> <u> LINE BY LINE EXPLANATION OF CODE </u></h3>
<p> <b> import cv2 </b> <br>
<b> import numpy as np </b> <br>
</p> <br>
<p> I have imported library cv2 and numpy in the above line as mentioned above. </p>
<br>
<p> <b> image = cv2.imread('rose.jpg') </b> </p><br>
<p> I have used cv2.imread() method in the code. <br>      
	cv2.imread() is a method in python that is used for loading an image from the specified file.                                                                          
  Here the image loaded is “rose.jpg” which is the image to be blurred. “img” is the variable here. Its syntax is as follows: <br>
	<i> <b> cv2.imread(path, flag) </b> </i> <br>
 <b>Parameters: </b> <br>
<b>path </b>: Path is a string that represents the path of the image to be read. <br>
<b>flag </b>: Flag specifies how the image is read.It’s default value is cv2.IMREAD_COLOR <br>
</p> <br>
<p> <b> sharpen_kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])</b> </p> <br>
<p> This is the convolution kernel which will be used for sharpening the image. The explanation of kernel is mentioned above. </p> <br>
<p> <b> sharpen = cv2.filter2D(image , 0 , sharpen_kernel) </b> </p> <br>
<p>By use of this line of code I have sharpened the image. <br>                 
In Open CV Sharpen filter doesn’t have an implemented function. Therefore, cv2.filter2D() function is used which processes the with an arbitrary filter. 
Colored images are often sharpened with this function. This operation convolves an image with the kernel. Its syntax is as follows: <br>
<i> <b>filter2D(src, dst, ddepth, kernel) </b></i> <br>

<b>Parameters: </b> <br>
<b>src</b>: It is the link of image to be deblurred. <br>
<b>dst </b> : It is the output image of the same size and type as src. <br>  
<b>ddepth </b> − An integer type variable representing the depth of the output image. <br>
<b>kernel </b> – It is the convolution kernel.<br>
This is what a sharpened image would look like: </p> <br>
<center> <img src = "rosesharpen.jpg"> <figcaption> Sharpened image </figcaption> </center> <br>
<p> <b> deblurred = cv2.fastNlMeansDenoisingColored(gausBlur,None,10,10,7,21) </b> </p> <br>
<p> By this line of code, I have denoised the image to remove noise from a sharpened image. <br>                                                                         
cv2.fastNlMeansDenoisingColored() function is the of Non-local Means Denoising algorithm implementation.
It is mostly used to remove Gaussian noise. Its syntax is as follows: <br>
<i> <b> cv2.fastNlMeansDenoisingColored( src [, dst [ , h [, hcolor [, templateWindowSize [, searchWindowSize ]]]]]) </b> </i> <br>
<b> Parameters: </b> <br>
<b>src</b> : It is the link of image to be deblurred. <br>                                                  
<b>dst </b> : Output image with the same size and type as src.<br>                            
<b>h</b>: filter strength is regulated by this component. The greater h component greater the image denoised but also removes noise from minute details and smaller the h component smaller the image denoised and also preserves the noise in minute details. <br>                                                                 
<b> templateWindowSize </b> : Template patch size in pixels that are used to compute weights. It Should be odd preferably 7 pixels. <br>                                                                            
<b> searchWindowSize </b> : Size of the window in pixels that can compute the weighted average for a given pixel. Just like templateWindowSize this should be odd too preferably 21 pixels. It affects the performance linearly that is greater searchWindowsSize, greater will be denoising time.<br>
This is what denoised image would look like :
</p> <br>
<center> <img src = "rosedenoise.jpg"> <figcaption> Denoised image </center> <br>
<p>  <b> cv2.imshow('sharpen', deblurred)</b> </p> <br>
<p> I have used cv2.imshow() function above. <br>
To display an image in a window, cv2.imshow() method is used.<br> 
Using this method we have shown the deblurred image i.e. the output image. Its syntax is as follows: <br>
<i> <b> cv2.imshow(window_name, image) </b> </i> <br>
<b> Parameters: </b> <br>
<b> window_name: </b> This represents the name of the window in which the image will be displayed.  <br>
<b> image: </b> It is the output displayed image. <br>
<p> <b> cv2.waitKey(0) </b> </p> <br>
<p> I have used cv2.waitKey() function. <br>                                                 
It is a function used for keyboard binding. Time in milliseconds is its arguments. For specified milliseconds this for any keyboard event. 
The program is continued if any key is pressed at that time. It waits indefinitely for a keystroke in case 0 is passed. </p> <br>
<h3> <u> OUTPUT IMAGE </u> </h3> <br>
<p> Following is the output of the code above: </p> <br>
<center> <img src= "rosedenoise.jpg"> <figcaption> Deblurred image </figcaption> </center> <br>
<p> After deblurring the image, I wondered if the image I deblurred is similar to the original one or if it is different from the original image.
If this algorithm was right or not. So I decided to take an original picture blur it and then again deblur it to confirm my method.
I choose the most popular image processing image Lena for this purpose. </p> <br>
<center> <img src = "lena2.jpg"> </center> <br>
<p> Then  I started to find ways to blur an image. </p> <br>
<h2> <u> TYPES OF BLURRING </u> </h2> <br>
<p> I found that there were 4 kinds of blurring methods: <br>
<ul type = "disc">
<li> Average Blur also referred to as box filter or average filter </li>
<li> Gaussian Blur also referred to as Gaussian filter </li>
<li> Median Blur also referred to as Median filter </li>
<li> Bilateral Blur also referred to as Bilateral filter </li> <br>
Average Blur and Gaussian blur are the most commonly used blurring techniques about which I tried and have discussed below: </p> <br>
<h2> <u> PREREQUISITES FOR BLURRING USING OPEN CV </u> </h2> <br>
<h3> <u> LIBRARIES </u> </h3>
<p> Before starting with blurring using open cv make sure you have installed the following libraries. </p>
<ol type="1"> <p>
<li> Open CV:It is a Python library that can be used to solve computer vision problems. 
    This library can be installed by writing the following code in command prompt or anaconda prompt: <b> Pip install opencv-python </b>
         It is imported as <b> import cv2 </b> in the code. </li> </p> </ol> <br>
<ol type ="1">
<li> <h3> <u> Average Blur </u> </h3> </li> <br>
<p> In the picture below we can see that the input image on the left is processed with the averaging filter (box filter). </p> <br>
<center><div class="row">
  <div class="column"> 
  	<img src = "lena2.jpg"> 
  	<figcaption> Original image </figcaption> </div>
    <div class="column"> 
    	<img src ="lenaavg.jpg"> 
    	<figcaption> Average blur image </figcaption></div>
     </center> <br>
<p> It is the basic blur filter. Here, it has the same value of 1/9 for all coefficient values.
On applying the convolution operator, we get an output the same as on the right side as shown.
The image will be more blurred as a filter size increases. </p> <br>
<center> <img src = "figure3.jpg"> <figcaption> Convolution of images in average blur </figcaption> </center> <br>
<p> This is the code of average filter which I tried : </p> <br>
<h3> <u> CODE </u> </h3> <br>
<p> <b> import cv2 <br>

img = cv2.imread("lena.jpg") <br>

blurImg = cv2.blur(img,(9,9)) <br>

cv2.imshow('Averaging',blurImg ) <br>

cv2.destroyAllWindows() <br>
</b> </p>
<h3> <u> LINE BY LINE EXPLANATION OF CODE </u> </h3> <br>
<p> <b> import cv2 </b> </p> <br>
<p> I have imported library cv2 in the above line as mentioned above. </p> <br>
<p> <b> img = cv2.imread("lena.jpg") </b> </p> <br>
<p>I have used cv2.imread() method in the code. <br>                                             
The explanation of this method is given above. </p> <br>
<p> <b> blurImg = cv2.blur(image,(9,9)) </b> </p> <br>
<p> I have used cv2.blur() method in the code. <br>
Using this method an image is blurred using the normalized box filter. The kernel which is represented below is used by the function to smooth an image: </p> <br>
<center> <img src ="figure4.jpg"> </center> <br>
<p> This the function that blurs the image by the average filter. Its syntax is as follows: </p> <br>
<i> <b> cv2.blur(src, ksize[, dst[, anchor[, borderType]]]) </b> </i> <br>
<p> <b> Parameters: </b> <br>
<b> src </b>: it's the link of the image which is to be blurred. <br>
<b> ksize </b>: A blurring kernel size tupple. <br>
<b> dst </b>: It is the output image of the identical size and type as src. <br>
<b> anchor </b> : An integer type variable used to represent anchor point. The point is (-1, -1) is its default value which implies that the anchor is at the kernel center.<br>
<b> borderType </b>: It is for type border to be added. It is defined by flags like cv2.BORDER_CONSTANT, cv2.BORDER_REFLECT, etc <br>
<p> <b> cv2.imshow('Averaging',blurImg ) </b> </p> <br>
<p> I have used cv2.imshow() function above 
The explanation of this function is given above. </p> <br>
<p> <b> cv2.waitKey(0) </b> </p> <br>
<p> I have used cv2.waitKey() function.                                                           
The explanation of this function is given above. </p> <br>
<p> <b> cv2.destroyAllWindows() </b> </p> <br>
<p> I have used cv2.destroyAllWindows() function.  Using this function all the windows we created are destroyed. </p> <br>
<h3> <u>  OUTPUT IMAGE </u> </h3> <br>
<p> This is the output I got after running the code: </p> <br>
<center> <img src="lenaavg"> <figcaption> Average Filter </figcaption> </center> <br>
<li> <h3> <u> Gaussian Blur </u> </h3> </li> <br>
<p>The Gaussian filter or blur is a slightly more complicated filter and is the most commonly used kernel in image processing it is called the Gaussian filter.
In the picture below we can see that the input image on the left is processed with the Gaussian Filter shown in right. </p><br>
<center><div class="row">
  <div class="column"> 
  	<img src = "lena2.jpg">
  	<figcaption> Original image </figcaption> </div>
    <div class="column"> 
    	<img src ="lenagaus.jpg"> 
    	<figcaption> Gaus blur image </figcaption></div>
     </center> <br>
<p>The famous Gaussian function is used for creation of this filter. 
The probability that events are centered around a mean value is represented by this function. 
Furthermore, the width of this function is controlled by the standard deviation (σ) of this function.
Sampling this function’s values, gives the coefficients for a Gaussian filter matrix. Effect of different (σ) values can be observed in the following image: </p> <br>
<center> <img src ="figure5.jpg"> <figcaption> 2D Gaussian distribution </figcaption> </center> <br>
<center> <img src ="figure6.jpg"> <figcaption> 3D Gaussian distribution </figcaption> </center> <br>
<p> The equation for a Gaussian filter kernel of size (2k+1)×(2k+1) is given by: </p> <br>
<center> <img src ="figure7.jpg"> </center> <br>
<p> A 5x5 gaussian filter will look like this : </p> <br>
<center> <img src ="figure8.jpg"> </center> <br>
<h3> <u> CODE </u> </h3> <br>
<p> <b> import cv2 <br>

img = cv2.imread("lena.jpg") <br> 

gausBlur = cv2.GaussianBlur(image, (5,5),0) <br>

cv2.imshow('Gaussian Blurring', gausBlur) <br>
cv2.waitKey(0) <br>
cv2.destroyAllWindows() <br>
</b> </p>
<h3> <u> LINE BY LINE EXPLANATION OF CODE </u> </h3> <br>
<p> All lines of code are explained except line 3 which is explained below.<br>
<b> gausBlur = cv2.GaussianBlur(image, (5,5),0) </b> <br>
I have used cv2.GaussianBlur() function for Gaussian blurring.<br>      
In this function, the width and height of the kernel specified should be positive and odd. 
The standard deviation in the X and Y directions should also be specified ascsigma X and sigma Y respectively. If only sigma X is specified, sigma Y is taken as equal to sigma X.
Its syntax is as follows: <br>
<i> <b> cv2.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType=BORDER_DEFAULT]]] ) </b> </i> <br>
<b>Parameters:</b> <br>
<b> src </b>: it's the link of image which is to be blurred. <br>
<b> ksize </b>: It is the Gaussian Kernel Size. If ksize is set to [0 0], then ksize is computed from sigma values. <br>
<b> dst </b>: It is the output image of the same size and type as src. <br>
<b> sigma X </b>: Kernel standard deviation along X-axis (horizontal direction). <br>                                                                                             
<b> sigma Y </b>: Kernel standard deviation along Y-axis (vertical direction). If sigma Y=0, then sigma X value is taken for sigma Y <br>
<b>borderType </b>: It depicts what kind of border to be added. It is defined by flags like cv2.BORDER_CONSTANT, cv2.BORDER_REFLECT, etc.<br>
<h3> <u> OUTPUT IMAGE </u> </h3><br>
<p> This is the output I got after running the above code : </p> <br>
<center> <img src="lenagaus.jpg"> <figcaption> Gaussian  Blur </figcaption> </center> <br>
<h2> <u> DEBLURRING OF IMAGES </u> </h2> <br>
<p> After learning about blurring I tried deblurring them again to verify the results of the algorithm used. This is what I did :<br>
<h3> <u> CODE </u> </h3> <br>
import cv2 <br>
import numpy as np <br>

image = cv2.imread('lena2.jpg') <br>

gausBlur = cv2.GaussianBlur(image, (5,5),0) <br>

sharpen_kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]]) <br>
sharpen = cv2.filter2D(gausBlur, 0 , sharpen_kernel) <br>

deblurred = cv2.fastNlMeansDenoisingColored(sharpen,None,10,10,7,21) <br>

cv2.imshow('deblurred', deblurred) <br>
cv2.waitKey() <br>

<h2> <u> RESULTS </u> </h2> <br>
After running this code these are the results I got. As it can be seen the original image and deblurred final images are very similar.
Hence the method I used was successful for deblurring of images. </p> <br>
<center><div class="row">
  <div class="column"> 
  	<img src = "lena2.jpg"> 
  	<figcaption> Original image </figcaption> </div>
    <div class="column"> 
    	<img src ="lenagaus.jpg"> 
    	<figcaption> Gaussian blur image </figcaption></div>
    <div class="column"> 
    	<img src="lenasharp.jpg">
    	<figcaption>Sharpened image </figcaption></div>
     </div>
     <div class ="column">
     <img src ="lenadenoise.jpg"> 
    	<figcaption> Denoise image </figcaption></div>
     </center> <br>
<h2> <u> REFERENCES </u> </h2> <br>
<p> For Learning about image deblurring and blurring I referred to the following websites and articles. These articles helped me a lot in learning deblurring and blurring of images</p><br> 
<a href="https://www.analyticsvidhya.com/blog/2020/09/how-to-perform-blur-detection-using-opencv-in-python/"> https://www.analyticsvidhya.com/blog/2020/09/how-to-perform-blur-detection-using-opencv-in-python/</a><br>
<a href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/convolve.htm"> https://homepages.inf.ed.ac.uk/rbf/HIPR2/convolve.htm </a><br>
<a href="https://debuggercafe.com/image-and-video-blurring-using-opencv-and-python/">https://debuggercafe.com/image-and-video-blurring-using-opencv-and-python/</a><br>
<a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html"> https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html </a><br>
<a href="http://datahacker.rs/004-how-to-smooth-and-sharpen-an-image-in-opencv/"> http://datahacker.rs/004-how-to-smooth-and-sharpen-an-image-in-opencv/ </a><br>

<h2> <u> CONCLUSION </u> </h2> <br>
<p>This is what I did to deblur images. It was a successful method but as said above there are many more methods to deblur images that can be tried out.
I hope this would help you also to deblur some images of your own.</p>
</body>
</html>